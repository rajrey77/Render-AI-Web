import fs from"fs";import dotenv from"dotenv";import{writeFile}from"fs/promises";import readline from"readline";import path from"path";import base64 from"base64-js";import{OpenAI}from"openai";dotenv.config();const envFilePath="./.env";if(!fs.existsSync("./.env")){const e='OPENAI_API_KEY="your_api_key_here"\nDISABLE_WARNING="false" # Enable at your own risk. Some OpenAI models are [very] expensive to use.';fs.writeFileSync("./.env",e),console.log(".env file created. Please fill in the API key.")}const gconfig={apiKey:process.env.OPENAI_API_KEY},persistentFilePath=path.join(path.dirname(""),"persistentData.json"),conversationsDir="./conversations";fs.existsSync(conversationsDir)||fs.mkdirSync(conversationsDir);const generatedAudioDir="./gen-audio";fs.existsSync("./gen-audio")||fs.mkdirSync("./gen-audio");const generatedImgsDir="./gen-imgs";fs.existsSync("./gen-imgs")||fs.mkdirSync("./gen-imgs");let persistentData={};if(fs.existsSync(persistentFilePath)){const e=fs.readFileSync(persistentFilePath,"utf8");persistentData=JSON.parse(e)}else persistentData={chatCreations:0};function savePersistentData(){fs.writeFileSync(persistentFilePath,JSON.stringify(persistentData,null,2))}process.on("exit",savePersistentData),process.on("SIGINT",(()=>{savePersistentData(),process.exit()}));const client=new OpenAI(gconfig);async function warn(){if("true"===process.env.DISABLE_WARNING)return!0;{const t=readline.createInterface({input:process.stdin,output:process.stdout});async function e(e){return new Promise((n=>t.question(e,n)))}return await async function(){let n,i="WARNING: Are you want to use this model? This model may be expensive. Make sure to check the OpenAI model usage rates. (more-info/y/n) ";for(;;){const t=await e(i);if("y"===t.toLowerCase()){n=!0;break}if("n"===t.toLowerCase()){n=!1;break}"more-info"===t.toLowerCase()?(console.log("WARNING: This warning was given to inform you that the model you are using may be expensive. Make sure to check the OpenAI model usage rates before continuing. To disable these messages, set DISABLE_WARNING to true in the .env file."),i="Do you want to proceed? (y/n) "):(console.log("WARING: Invalid input. Please enter y or n or more-info."),i="Do you want to proceed? (y/n) ")}return t.close(),n}()}}async function getResponse(e){e={type:"chat",model:"gpt-4o-mini",prompt:"",messages:[],sysInstructions:"",maxTokens:750,attachImage:!1,imagePath:"",test:!1,...e};const t=new Promise((async(t,n)=>{try{let o,a={role:"user",content:e.prompt};async function i(e){const t=fs.readFileSync(e);return base64.fromByteArray(new Uint8Array(t))}const s=e.imagePath;if("chat"===e.type){let r=e.messages;if(e.attachImage)if(Array.isArray(s)){let l={role:"user",content:[{type:"text",text:e.prompt}]};for(const c of s){const m={type:"image_url",image_url:{url:`data:image/${path.extname(c).slice(1)};base64,${await i(c)}`}};l.content.push(m)}r.push(l)}else{const p=[{type:"text",text:e.prompt},{type:"image_url",image_url:{url:`data:image/${path.extname(e.imagePath).slice(1)};base64,${await i(s)}`}}];r.push({role:"user",content:p})}o=await client.chat.completions.create({model:e.model,messages:""===e.sysInstructions?r:function(t){let n=t.toSpliced(0,0,{role:"system",content:e.sysInstructions});return n.push(a),console.log(n),n}(e.messages),max_tokens:e.maxTokens})}else"completion"===e.type?o=await client.completions.create({model:e.model,prompt:a,max_tokens:e.maxTokens}):"embedding"===e.type&&(o=await client.embeddings.create({model:e.model,input:a}));t(o)}catch(d){n(d)}}));if(e.test)return t;{const n=await t;return"embedding"===e.type?n.data:n.choices[0].message.content}}async function cmdChat(e,t=!1,n=""){const i=readline.createInterface({input:process.stdin,output:process.stdout});async function o(e){return new Promise((t=>i.question(e,t)))}return persistentData.chatCreations++,await async function(){let a=[];for(;;){const t=await o("You: ");if("e-"===t.toLowerCase())break;a.push({role:"user",content:t});const n=await getResponse({...e,messages:a});console.log("\nAI:",n,"\n"),a.push({role:"assistant",content:n})}return i.close(),t&&writeFile(`./conversations/${n}.txt`,JSON.stringify(a,null,2)).then((()=>{console.log("Conversation saved.")})).catch((e=>{throw e})),a}()}function getChat(e){const t=path.join("./conversations",`${e}.txt`);if(fs.existsSync(t)){const e=fs.readFileSync(t,"utf8");return JSON.parse(e)}console.log("Chat not found.")}function deleteChat(e){const t=path.join("./conversations",`${e}.txt`);fs.existsSync(t)?(fs.unlinkSync(t),console.log("Chat deleted.")):console.log("Chat not found.")}function listChats(){return fs.readdirSync("./conversations").filter((e=>e.endsWith(".txt"))).map((e=>e.replace(".txt","")))}async function generateAudio(e,t,n){let i;if(!await warn())return"Audio generation cancelled.";for(let t=0;t<process.env.ADV.length;t++)pass===process.env.ADV[t]&&(i=await client.chat.completions.create({model:"gpt-4o-audio-preview",modalities:["text","audio"],audio:{voice:"alloy",format:"mp3"},messages:[{role:"system",content:n},{role:"user",content:e}]}));const o=base64.toByteArray(i.choices[0].message.audio.data);fs.writeFileSync(t,o)}async function generateImage(e={},t={}){if(!await warn())return"Image generation cancelled.";let n={file:!1,path:"",fileName:""};n={...n,...t};let i={model:"dall-e-3",prompt:"",n:1,size:"1024x1024",response_format:"url"};i={...i,...e};const o=await client.images.generate(i);if(n.file){const e=o.data[0].url,t=(await import("node-fetch")).default,i=await t(e),a=Buffer.from(await i.arrayBuffer()),s=n.fileName?n.fileName:"generated_image.png",r=n.path?path.join(n.path,s):path.join("./gen-imgs",s);fs.writeFileSync(r,a),console.log(`Image saved as ${r}`)}return o.data[0].url}function updateSystemInstructions(e,t){const n=path.join("./conversations",`${e}.txt`);if(!fs.existsSync(n))return void console.log("Chat not found.");const i=fs.readFileSync(n,"utf8"),o=JSON.parse(i);o.forEach((e=>{"system"===e.role&&(e.content=t)})),fs.writeFileSync(n,JSON.stringify(o,null,2)),console.log("System instructions updated.")}function logUsage(e,t,n){const i=path.join(path.dirname(""),"usage.log"),o=`${(new Date).toISOString()} - Endpoint: ${e}, Model: ${t}, Tokens: ${n}\n`;fs.appendFileSync(i,o),console.log("Usage logged.")}async function improvePrompt(e,t,n){const i=await getResponse(n?{prompt:e,messages:[{role:"user",content:"John is available at 12:30 to 2:00. Lisa is available from 11:00 to 1:30. Daniel is available from 1:30 to 3:00. Find a time for a 30 minute meeting for all 3 of them."},{role:"assistant",content:'\n                **Original Prompt**:  \n                "John is available at 12:30 to 2:00. Lisa is available from 11:00 to 1:30. Daniel is available from 1:30 to 3:00. Find a time for a 30 minute meeting for all 3 of them."\n                \n                **Identified Issues**:  \n                - **Complexity and Clarity**: The prompt involves multiple time slots that are not immediately intuitive to reconcile. It requires careful analysis to determine a common time block.\n                - **Ambiguity**: The instructions do not specify whether to find the earliest possible meeting time or if any time slot will do.\n                - **Lack of Structure**: The prompt doesn’t guide the responder toward a specific format for the answer.\n                - **No Additional Instructions**: It could benefit from indicating what to do if no common time is found.\n                \n                **Improved Prompt**:  \n                "Determine a time slot for a 30-minute meeting that accommodates the schedules of John, Lisa, and Daniel. Consider the following availability:\n                - John: 12:30 PM - 2:00 PM\n                - Lisa: 11:00 AM - 1:30 PM\n                - Daniel: 1:30 PM - 3:00 PM\n                \n                Please:\n                1. Identify any overlaps in their schedules allowing for a 30-minute meeting.\n                2. Suggest the earliest possible time for the meeting.\n                3. If no common time exists, state this clearly and suggest alternatives if feasible.\n                Present your findings in a concise format, clearly stating the time for the proposed meeting or summarizing your conclusion."\n                \n                **Reasoning Behind Changes**:  \n                - **Complexity Simplification**: By requesting an identified overlap, it makes it easier to deduce shared availability.\n                - **Added Specificity**: By specifying the need for the earliest possible time, it adds a prioritization to the solution process.\n                - **Answer Format Guidance**: By instructing a clear format for presentation, it ensures a structured response.\n                - **Handling of No Solution Scenarios**: By including instructions on what to do if no time is available, it preempts potential confusion in case there’s no overlap.'}],sysInstructions:'\nGenerate a detailed guide with specific suggestions to improve a given prompt using prompt engineering.\n\nAnalyze the provided prompt to determine its purpose, identify areas for potential improvements, provide alternative formulations, and enhance clarity, engagement, and effectiveness.\n\n# Steps\n\n1. **Understand the Initial Prompt**: Carefully read and understand what the provided prompt is trying to achieve, its target objective, and desired outcome. Break down the intent if needed.\n2. **Identify Issues and Scope for Improvement**: Highlight areas where the prompt may be lacking (e.g. clarity, conciseness, specificity, tone). Look for:\n   - **Clarity Issues**: Is the intent of the prompt clear?\n   - **Detail Level**: Does the prompt need more examples or additional context?\n   - **Ambiguity**: Are there any vague instructions that may lead to different or incorrect outcomes?\n   - **Structure**: Is the output format well-defined?\n   - **Additional Context**: Is broader context required for better performance?\n3. **Rewrite Improvements**: Revise the prompt with detailed changes that address the shortcomings. Describe how these changes will make the prompt more effective and why they are needed.\n4. **Add Specific Examples**: Where appropriate, suggest specific examples, and include placeholders to guide a consistent output for varied scenarios.\n5. **Optional Enhancements**: Provide details on optional components or bonus refinements to further elevate the prompt (e.g., including reasoning steps if applicable). \n\n# Output Format\n\nRespond in sections:\n1. **Original Prompt**: Include the original prompt as provided.\n2. **Identified Issues**: List out specific areas in need of improvement.\n3. **Improved Prompt**: Provide the updated version of the prompt.\n4. **Reasoning Behind Changes**: Explain why each change was made and how it will improve the prompt\'s overall efficacy in achieving its goal.\n\n# Example\n\n**Original Prompt**:  \n"Describe a situation in which you were proud of your accomplishments."\n\n**Identified Issues**:  \n- **Lack of Clarity**: The instruction is vague. What type of accomplishment does it refer to? Is it personal or professional?\n- **Needs Better Context**: Including more context would guide the user better, e.g., timeline, scale of accomplishment.\n- **No Output Format Guidance**: The output requirements (length, tone, specific details required) are not clearly defined.\n\n**Improved Prompt**:  \n"Think of a personal or professional accomplishment from the past three years that made you feel proud. Provide a detailed account, including:\n  - What the accomplishment was.\n  - The steps you took to achieve it.\n  - What obstacles you faced and how you overcame them.\nWrite in 4-5 sentences. Aim for a positive and reflective tone."\n\n**Reasoning Behind Changes**:  \n- **Specification**: Narrowing down "personal or professional" helps contextualize the prompt.\n- **Timeline**: Adding a \'past three years\' horizon provides a clear boundary, making it easier to think of examples.\n- **Guidance on Detail**: Instructing the user which aspects to describe adds structure to the response.\n- **Output Parameters**: Specifying length and tone helps ensure consistency and matches the desired level of response. \n\n# Notes\n\n- Always consider incorporating parameters for output format and tone, especially when the initial prompt is open-ended.\n- Ensure that revisions maintain the alignment with the original intent while enhancing overall clarity and engagement.\n        ',maxTokens:t}:{prompt:e,messages:[{role:"user",content:"John is available at 12:30 to 2:00. Lisa is available from 11:00 to 1:30. Daniel is available from 1:30 to 3:00. Find a time for a 30 minute meeting for all 3 of them."},{role:"assistant",content:"\nDetermine a time slot for a 30-minute meeting that accommodates the schedules of John, Lisa, and Daniel. Consider the following availability:\n- John: 12:30 PM - 2:00 PM\n- Lisa: 11:00 AM - 1:30 PM\n- Daniel: 1:30 PM - 3:00 PM\n\nPlease:\n1. Identify any overlaps in their schedules allowing for a 30-minute meeting.\n2. Suggest the earliest possible time for the meeting.\n3. If no common time exists, state this clearly and suggest alternatives if feasible.\nPresent your findings in a concise format, clearly stating the time for the proposed meeting or summarizing your conclusion.    \n            "}],sysInstructions:"\nGenerate a detailed guide with specific suggestions to improve a given prompt using prompt engineering.\n\nAnalyze the provided prompt to determine its purpose, identify areas for potential improvements, provide alternative formulations, and enhance clarity, engagement, and effectiveness.\n\n# Steps\n\n1. **Understand the Initial Prompt**: Carefully read and understand what the provided prompt is trying to achieve, its target objective, and desired outcome. Break down the intent if needed.\n2. **Identify Issues and Scope for Improvement**: Highlight areas where the prompt may be lacking (e.g. clarity, conciseness, specificity, tone). Look for:\n   - **Clarity Issues**: Is the intent of the prompt clear?\n   - **Detail Level**: Does the prompt need more examples or additional context?\n   - **Ambiguity**: Are there any vague instructions that may lead to different or incorrect outcomes?\n   - **Structure**: Is the output format well-defined?\n   - **Additional Context**: Is broader context required for better performance?\n3. **Rewrite Improvements**: Revise the prompt with detailed changes that address the shortcomings. Describe how these changes will make the prompt more effective and why they are needed.\n4. **Add Specific Examples**: Where appropriate, suggest specific examples, and include placeholders to guide a consistent output for varied scenarios.\n5. **Optional Enhancements**: Provide details on optional components or bonus refinements to further elevate the prompt (e.g., including reasoning steps if applicable). \n\n# Notes\n\n- Always consider incorporating parameters for output format and tone, especially when the initial prompt is open-ended.\n- Ensure that revisions maintain the alignment with the original intent while enhancing overall clarity and engagement.\n- Only share the improved prompt with the user, nothing else.\n        ",maxTokens:t});return await i}const chat={cmd:cmdChat,getResponse:getResponse,get:getChat,delete:deleteChat,list:listChats,updateSystemInstructions:updateSystemInstructions},audio={generate:generateAudio},image={generate:generateImage},utils={logUsage:logUsage,improvePrompt:improvePrompt};export{chat,audio,image,utils};